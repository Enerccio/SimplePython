"""
SimplePython - embeddable python interpret in java
Copyright (c) Peter Vanusanik, All rights reserved.
 
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 3.0 of the License, or (at your option) any later version.
 
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public
License along with this library.
"""

# all python doable builtin functions are here

import math

def abs(x):
    if x > 0:
        return True
    return False

def all(iterable):
    for i in iterable:
        if not i: return False
    return True

def any(iterable):
    for i in iterable:
        if i: return True 
    return False

def callable(object):
    t = type(object)
    if t == function(): return True
    if t == method(): return True
    if t == type(): return True
    if t == javamethod(): return True
    return hasattr(object, "__call__")

def cmp(x, y):
    if x < y:
        return -1
    elif x == y:
        return 0
    else:
        return 1
    
def divmod(a, b):
    return int(math.floor(a/b)), int(a%b)

def __iter():
    class iter(object):
        def __init__(self, o):
            self.__data_source = o
            self.__index = 0
            
        def __iter__(self):
            return self
        
        def next(self):
            try:
                i = self.__index
                self.__index += 1
                return self.__data_source[i]
            except IndexError:
                raise StopIteration()
            
    def factory(obj):
        if hasattr(obj, "__iter__"):
            return obj.__iter__()
        else:
            return iter(obj)
    factory.__name__ = "iter"
    return factory

iter = __iter()
__iter = None

class enumerate(object):
    def __init__(self, seq, start=0):
        self.__it = iter(seq)
        self.__start = 0
        
    def __iter__(self):
        return self
    
    def next(self):
        i = self.__start
        self.__start += 1
        return i, self.__it.next()

def filter(f, it):
    l = []
    for i in it:
        if f(i):
            l.append(i)
    return l

def issubclass(cls, classinfo):
    if type(classinfo) == tuple:
        for c in classinfo:
            if issubclass(cls, c):
                return True
        return False
    return classinfo in mro(cls)

class set(object):
    def __init__(self, iterable=None):
        if iterable is None:
        	self.__inner_map = dict()
        else:
        	self.__inner_map = { o : o for o in iterable }
    
    def __str__(self):
        return "set(" + str(self.__inner_map.keys()) + ")"
    
    def add(self, o):
        self.__inner_map[o] = o;
        
    def __contains__(self, key):
        return key in self.__inner_map

class xrange(object):
    class iter(object):
        def __init__(self, range):
            self.__range = range
            self.__start = range.start
            
        def __iter__(self):
            return self
        
        def next(self):
            if self.__start >= self.__range.stop:
                raise StopIteration()
            value = self.__start;
            self.__start += self.__range.step
            return value
    
    def __init__(self, arg1, arg2=None, arg3=1):
        if arg2 is None:
            self.stop = int(arg1)
            self.start = 0
            self.step = 1
        else:
            self.start = int(arg1)
            self.stop = int(arg2)
            self.step = int(arg3)
    
    def __iter__(self):
        return iter(self)
   
def range(arg1, arg2=None, arg3=1):
    r = xrange(arg1, arg2, arg3)
    l = []
    for v in r:
        l.append(v)
    return l

class super(object):
    def __init__(self, cls, inst=None):
        self.__cls = cls
        self.__inst = inst
        self.__mro = mro(cls)[1:]
        
    def __getattribute__(self, key):
        cls, arg = object.__getattribute__(self, "__find_applicable")(key);
        if type(arg) == boundfunction:
            if object.__getattribute__(self, "__inst") is not None:
                return method(arg.__func__, object.__getattribute__(self, "__inst"), cls)
            else:
                return arg
        else:
            return arg
        
    def __find_applicable(self, key):
        for cls in object.__getattribute__(self, "__mro"):
            if (hasattr(cls, key)):
                return cls, getattr(cls, key)
        raise AttributeError("unknown attribute " + key)
