"""
SimplePython - embeddable python interpret in java
Copyright (c) Peter Vanusanik, All rights reserved.
 
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 3.0 of the License, or (at your option) any later version.
 
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public
License along with this library.
"""

def abs(x):
    if x > 0:
        return True
    return False

def all(iterable):
    pass

def any(iterable):
    pass

def callable(object):
    t = type(object)
    if t == function(): return True
    if t == method(): return True
    if t == type(): return True
    if t == javamethod(): return True
    return hasattr(object, "__call__")

def cmp(x, y):
    if x < y:
        return -1
    elif x == y:
        return 0
    else:
        return 1

def __iter():
    class iter(object):
        def __init__(self, o):
            self.__data_source = o
            self.__index = 0
            
        def __iter__(self):
            return self
        
        def next(self):
            try:
                i = self.__index
                self.__index += 1
                return self.__data_source[i]
            except IndexError:
                raise StopIteration()
            
    def factory(obj):
        if hasattr(obj, "__iter__"):
            return obj.__iter__()
        else:
            return iter(obj)
    factory.__name__ = "iter"
    return factory

class set(object):
    def __init__(self, iterable=None):
        self.__inner_map = {}
        pass #TODO
    
    def __str__(self):
        return "set=[" + self.__tostr() + "]"
    
    def __tostr(self):
        return "" #TODO
    
    def add(self, o):
        self.__inner_map[o] = o;

iter = __iter()
__iter = None

class xrange(object):
    class iter(object):
        def __init__(self, range):
            self.__range = range
            self.__start = range.start
            
        def __iter__(self):
            return self
        
        def next(self):
            if self.__start >= self.__range.stop:
                raise StopIteration()
            value = self.__start;
            self.__start += self.__range.step
            return value
    
    def __init__(self, arg1, arg2=None, arg3=1):
        if arg2 is None:
            self.stop = int(arg1)
            self.start = 0
            self.step = 1
        else:
            self.start = int(arg1)
            self.stop = int(arg2)
            self.step = int(arg3)
    
    def __iter__(self):
        return iter(self)
   
"""
def range(arg1, arg2=None, arg3=1):
    r = xrange(arg1, arg2, arg3)
    l = []
    for v in r:
        l.append(v)
    return l

class super(object):
    def __init__(self, cls, inst=None):
        self.__cls = cls
        self.__inst = inst
        self.__mro = mro(cls)[1:]
        
    def __getattr__(self, key):
        arg = __find_applicable(key);
        if type(arg) == function:
            if self.__inst is not None:
                return method(arg, self.__inst, arg)
            else:
                return arg
        else:
            return arg
        
    def __inst(self, key):
        for cls in self.__mro:
            if (hasattr(cls, key)):
                return getattr(cls, key)
        raise AttributeError("unknown attribute " + key)
        
"""
